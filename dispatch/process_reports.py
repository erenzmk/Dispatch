"""
Automate dispatch call summaries.

This script processes daily technician call reports. For each day directory
(e.g. ``Juli_25/01.07``) it expects a morning file named with ``7`` and an
evening file named with ``19``. The morning report counts each technician's
total calls and how many are "new" (``Open Date Time`` equals the previous
business day) versus "old". The evening report lists the still-open calls so the
script can derive how many were completed during the day.

The aggregated values are written into ``Liste.xlsx`` on the sheet for the
corresponding month. The workbook contains weekly column blocks consisting of
13 columns:

    name, date, weekday, pudo, pickup time, valid, info, pre-closed,
    total calls, old calls, new calls, details, mails

Blocks are repeated for each week and separated by an empty column.  The first
block starts at column ``A``.  To update values for a given date ``d`` the
block index is ``(d.day-1)//7`` and the starting column is ``1 + index*14``.

The script requires :mod:`openpyxl` for reading and writing Excel files.
"""

from __future__ import annotations

import argparse
import datetime as dt
import logging
from pathlib import Path
from typing import Dict, Iterable, Tuple
import warnings
from contextlib import closing
from .name_aliases import canonical_name

try:  # pragma: no cover - import guard
    from openpyxl import load_workbook
except Exception:  # pragma: no cover - missing dependency
    load_workbook = None  # type: ignore[assignment]

# Known noisy openpyxl warnings to suppress when loading workbooks.
OPENPYXL_WARNINGS = [
    "Workbook contains no default style, apply openpyxl's default",
    "Data Validation extension is not supported and will be removed",
]


def safe_load_workbook(filename: Path | str, *args, **kwargs):
    """Load a workbook while suppressing known openpyxl warnings.

    Some Excel files generated by third-party systems trigger noisy warnings
    about missing default styles or unsupported data validation extensions.
    These warnings are irrelevant for our processing and would clutter the
    output, especially on Windows where they are printed for every run.

    Parameters mirror :func:`openpyxl.load_workbook`.
    """

    path = Path(filename)
    if not path.exists():
        raise FileNotFoundError(f"Workbook not found: {path}")

    if load_workbook is None:
        raise RuntimeError("openpyxl is required to load workbooks")

    with warnings.catch_warnings():
        for msg in OPENPYXL_WARNINGS:
            warnings.filterwarnings("ignore", message=msg, category=UserWarning)
        return load_workbook(path, *args, **kwargs)


HEADER_MARKER = "Employee ID"
PREV_DAY_MAP = {
    0: "Montag",
    1: "Dienstag",
    2: "Mittwoch",
    3: "Donnerstag",
    4: "Freitag",
    5: "Samstag",
    6: "Sonntag",
}

# Mapping of month numbers to German month names used in ``Liste.xlsx``
MONTH_MAP = {
    1: "Januar",
    2: "Februar",
    3: "MÃ¤rz",
    4: "April",
    5: "Mai",
    6: "Juni",
    7: "Juli",
    8: "August",
    9: "September",
    10: "Oktober",
    11: "November",
    12: "Dezember",
}


def excel_to_date(value):
    """Convert an Excel serial or datetime to a :class:`datetime.date`."""
    if isinstance(value, dt.datetime):
        return value.date()
    origin = dt.date(1899, 12, 30)
    return (origin + dt.timedelta(days=float(value)))


def prev_business_day(day: dt.date) -> dt.date:
    """Return the previous business day (skip weekends)."""
    day -= dt.timedelta(days=1)
    while day.weekday() >= 5:  # 5=Sat,6=Sun
        day -= dt.timedelta(days=1)
    return day


def load_calls(path: Path, valid_names: Iterable[str] | None = None) -> Tuple[dt.date, Dict[str, Dict[str, int]]]:
    """Load a call report and summarise per technician.

    Parameters
    ----------
    path:
        Excel file to read.
    valid_names:
        Iterable of canonical names from ``Liste.xlsx`` used to match
        technician names via fuzzy comparison.
    """
    with closing(safe_load_workbook(path, data_only=True, read_only=True)) as wb:
        def _norm(value: str) -> str:
            return value.strip().lower()


        header_row = None
        header_row_idx = None
        ws = None
        marker_norm = _norm(HEADER_MARKER)
        for sheet in wb.worksheets:
            for idx, row in enumerate(
                sheet.iter_rows(min_row=1, max_row=20, values_only=True), 1
            ):
                if row and any(
                    _norm(cell) == marker_norm for cell in row if isinstance(cell, str)
                ):
                    header_row = list(row)
                    header_row_idx = idx
                    ws = sheet
                    break
            if ws is not None:
                break
        if ws is None or header_row is None:
            raise ValueError("Header row not found in report")

        header_map = {
            _norm(cell): idx for idx, cell in enumerate(header_row) if isinstance(cell, str)
        }
        required = ["Employee Name", "Open Date Time"]
        missing = [col for col in required if _norm(col) not in header_map]
        if missing:
            raise ValueError(
                "Missing required column(s): " + ", ".join(missing)
            )

        name_idx = header_map[_norm("Employee Name")]
        open_idx = header_map[_norm("Open Date Time")]

        target_cell = ws.cell(row=2, column=1).value
        target_date = excel_to_date(target_cell)
        prev_day = prev_business_day(target_date)

        summary: Dict[str, Dict[str, int]] = {}
        for row in ws.iter_rows(min_row=header_row_idx + 1, values_only=True):
            if row and any(
                _norm(cell) == marker_norm for cell in row if isinstance(cell, str)
            ):
                continue
            if not row or row[name_idx] in (None, ""):
                continue
            tech_raw = str(row[name_idx]).strip()
            tech = canonical_name(tech_raw, valid_names or [])
            if valid_names and tech not in valid_names:
                logging.warning("Unknown technician '%s' in %s", tech_raw, path)

            open_date = excel_to_date(row[open_idx])
            data = summary.setdefault(tech, {"total": 0, "new": 0, "old": 0})
            data["total"] += 1
            if open_date == prev_day:
                data["new"] += 1
            else:
                data["old"] += 1
        return target_date, summary


def update_liste(
    liste: Path,
    month_sheet: str,
    day: dt.date,
    morning: Dict[str, Dict[str, int]],
    evening: Dict[str, Dict[str, int]],
):
    """Write aggregated values into the ``Liste.xlsx`` workbook."""
    if not morning:
        raise ValueError("Morning report produced no data")
    wb = safe_load_workbook(liste)
    try:
        if month_sheet not in wb.sheetnames:
            raise KeyError(f"Worksheet {month_sheet} does not exist in {liste}")
        ws = wb[month_sheet]

        # Canonicalise technician names already present in the sheet
        names_in_sheet: list[str] = []
        for row in range(2, ws.max_row + 1):
            cell = ws.cell(row=row, column=1)
            if not cell.value:
                continue
            name = str(cell.value).strip()
            canon = canonical_name(name, names_in_sheet)
            cell.value = canon
            names_in_sheet.append(canon)

        def canonicalize_summary(summary: Dict[str, Dict[str, int]]) -> Dict[str, Dict[str, int]]:
            result: Dict[str, Dict[str, int]] = {}
            for name, stats in summary.items():
                canon = canonical_name(name, names_in_sheet)
                agg = result.setdefault(canon, {"total": 0, "new": 0, "old": 0})
                agg["total"] += stats["total"]
                agg["new"] += stats["new"]
                agg["old"] += stats["old"]
            return result

        morning = canonicalize_summary(morning)
        evening = canonicalize_summary(evening)

        week_index = (day.day - 1) // 7
        start_col = 1 + week_index * 14
        remaining = set(morning)

        for row in range(2, ws.max_row + 1):
            name_cell = ws.cell(row=row, column=1)
            tech = str(name_cell.value).strip() if name_cell.value else None
            if not tech or tech not in morning:
                continue
            remaining.discard(tech)
            day_data = morning[tech]
            eve_total = evening.get(tech, {}).get("total", 0)
            closed = day_data["total"] - eve_total
            ws.cell(row=row, column=start_col + 1).value = day
            ws.cell(row=row, column=start_col + 2).value = PREV_DAY_MAP[day.weekday()]
            ws.cell(row=row, column=start_col + 7).value = closed
            ws.cell(row=row, column=start_col + 8).value = day_data["total"]
            ws.cell(row=row, column=start_col + 9).value = day_data["old"]
            ws.cell(row=row, column=start_col + 10).value = day_data["new"]

        for tech in remaining:
            row = ws.max_row + 1
            ws.cell(row=row, column=1).value = tech
            day_data = morning[tech]
            eve_total = evening.get(tech, {}).get("total", 0)
            closed = day_data["total"] - eve_total
            ws.cell(row=row, column=start_col + 1).value = day
            ws.cell(row=row, column=start_col + 2).value = PREV_DAY_MAP[day.weekday()]
            ws.cell(row=row, column=start_col + 7).value = closed
            ws.cell(row=row, column=start_col + 8).value = day_data["total"]
            ws.cell(row=row, column=start_col + 9).value = day_data["old"]
            ws.cell(row=row, column=start_col + 10).value = day_data["new"]

        wb.save(liste)
    finally:
        wb.close()


def main(argv: Iterable[str] | None = None) -> None:
    parser = argparse.ArgumentParser(description="Process dispatch reports")
    parser.add_argument(
        "day_dir",
        type=Path,
        help="Directory containing daily reports (e.g. Juli_25/01.07)",
    )
    parser.add_argument("liste", type=Path, help="Path to Liste.xlsx")
    args = parser.parse_args(list(argv) if argv is not None else None)

    # Determine year from parent directory (e.g. ``Juli_25`` -> 2025)
    # or fall back to the current system year.
    parent = args.day_dir.parent.name
    year_part = None
    if "_" in parent:
        suffix = parent.rsplit("_", 1)[-1]
        if suffix.isdigit():
            year_part = int(suffix)
            if year_part < 100:
                year_part += 2000
    if year_part is None:
        year_part = dt.date.today().year

    day_str = f"{args.day_dir.name}.{year_part}"
    day = dt.datetime.strptime(day_str, "%d.%m.%Y").date()
    month_sheet = f"{MONTH_MAP[day.month]}_{day.strftime('%y')}"

    # Read existing technician names to aid fuzzy matching
    name_wb = safe_load_workbook(args.liste, read_only=True)
    if month_sheet not in name_wb.sheetnames:
        raise KeyError(f"Worksheet {month_sheet} does not exist in {args.liste}")
    ws_names = name_wb[month_sheet]
    valid_names = [
        str(ws_names.cell(row=r, column=1).value).strip()
        for r in range(2, ws_names.max_row + 1)
        if ws_names.cell(row=r, column=1).value
    ]
    name_wb.close()

    morning_files = list(args.day_dir.glob("*7*.xlsx"))
    if not morning_files:
        raise FileNotFoundError(
            f"Morning report (*7*.xlsx) not found in {args.day_dir}"
        )
    morning = morning_files[0]

    evening_files = list(args.day_dir.glob("*19*.xlsx"))
    if not evening_files:
        raise FileNotFoundError(
            f"Evening report (*19*.xlsx) not found in {args.day_dir}"
        )
    evening_file = evening_files[0]

    target_date, morning_summary = load_calls(morning, valid_names)
    _, evening_summary = load_calls(evening_file, valid_names)
    update_liste(
        args.liste, month_sheet, target_date, morning_summary, evening_summary
    )


if __name__ == "__main__":
    main()
