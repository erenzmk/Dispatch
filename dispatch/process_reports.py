"""
Automate dispatch call summaries.

This script processes daily technician call reports. For each day directory
(e.g. ``reports/2025-07/01``) it expects a morning file named with ``7`` and an
evening file named with ``19``. The morning report counts each technician's
total calls and how many are "new" (``Open Date Time`` equals the previous
business day) versus "old". The evening report lists the still-open calls so the
script can derive how many were completed during the day.

The aggregated values are written into ``Liste.xlsx`` on the sheet for the
corresponding month. The workbook contains weekly column blocks consisting of
13 columns:

    name, date, weekday, pudo, pickup time, valid, info, pre-closed,
    total calls, old calls, new calls, details, mails

Blocks are repeated for each week and separated by an empty column. Each day
occupies its own 13-column block and weeks consist of seven such blocks.
The first block starts at column ``A``.  For a date ``d`` the week index is
``(d.day-1)//7`` and the day index within the week is ``(d.day-1)%7``.  The
starting column is therefore ``1 + week_index*14*7 + day_index*14``.

The script requires :mod:`openpyxl` for reading and writing Excel files.
"""

from __future__ import annotations

import argparse
import datetime as dt
import logging
from pathlib import Path
from typing import Dict, Iterable, Tuple
import warnings
from contextlib import closing
from .name_aliases import canonical_name


logger = logging.getLogger(__name__)

try:  # pragma: no cover - import guard
    from openpyxl import load_workbook
except Exception:  # pragma: no cover - missing dependency
    load_workbook = None  # type: ignore[assignment]

# Known noisy openpyxl warnings to suppress when loading workbooks.
OPENPYXL_WARNINGS = [
    "Workbook contains no default style, apply openpyxl's default",
    "Data Validation extension is not supported and will be removed",
]


def safe_load_workbook(filename: Path | str, *args, **kwargs):
    """Load a workbook while suppressing known openpyxl warnings.

    Some Excel files generated by third-party systems trigger noisy warnings
    about missing default styles or unsupported data validation extensions.
    These warnings are irrelevant for our processing and would clutter the
    output, especially on Windows where they are printed for every run.

    Parameters mirror :func:`openpyxl.load_workbook`.
    """

    path = Path(filename)
    if not path.exists():
        raise FileNotFoundError(f"Workbook not found: {path}")

    if load_workbook is None:
        raise RuntimeError("openpyxl is required to load workbooks")

    with warnings.catch_warnings():
        for msg in OPENPYXL_WARNINGS:
            warnings.filterwarnings("ignore", message=msg, category=UserWarning)
        return load_workbook(path, *args, **kwargs)


HEADER_MARKER = "Employee ID"
PREV_DAY_MAP = {
    0: "Montag",
    1: "Dienstag",
    2: "Mittwoch",
    3: "Donnerstag",
    4: "Freitag",
    5: "Samstag",
    6: "Sonntag",
}

# Mapping of month numbers to German month names used in ``Liste.xlsx``
MONTH_MAP = {
    1: "Januar",
    2: "Februar",
    3: "März",
    4: "April",
    5: "Mai",
    6: "Juni",
    7: "Juli",
    8: "August",
    9: "September",
    10: "Oktober",
    11: "November",
    12: "Dezember",
}


def excel_to_date(value):
    """Convert an Excel serial or datetime to a :class:`datetime.date`."""
    if isinstance(value, dt.datetime):
        return value.date()
    origin = dt.date(1899, 12, 30)
    return (origin + dt.timedelta(days=float(value)))


def prev_business_day(day: dt.date) -> dt.date:
    """Return the previous business day (skip weekends)."""
    day -= dt.timedelta(days=1)
    while day.weekday() >= 5:  # 5=Sat,6=Sun
        day -= dt.timedelta(days=1)
    return day


def load_calls(
    path: Path,
    valid_names: Iterable[str] | None = None,
) -> Tuple[dt.date, Dict[str, Dict[str, int]], list[str]]:
    """Load a call report and summarise per technician.

    Parameters
    ----------
    path:
        Excel file to read.
    valid_names:
        Iterable of canonical names from ``Liste.xlsx`` used to match
        technician names via fuzzy comparison.
    """
    with closing(safe_load_workbook(path, data_only=True, read_only=True)) as wb:
        def _norm(value: str) -> str:
            return value.strip().lower()

        marker_norm = _norm(HEADER_MARKER)
        summary: Dict[str, Dict[str, int]] = {}
        unknown: set[str] = set()
        target_date: dt.date | None = None
        prev_day: dt.date | None = None
        missing_required: list[str] | None = None

        for sheet in wb.worksheets:
            header_row = None
            header_row_idx = None
            for idx, row in enumerate(
                sheet.iter_rows(min_row=1, max_row=20, values_only=True), 1
            ):
                if row and any(
                    _norm(cell) == marker_norm for cell in row if isinstance(cell, str)
                ):
                    header_row = list(row)
                    header_row_idx = idx
                    break
            if header_row is None:
                continue

            header_map = {
                _norm(cell): idx for idx, cell in enumerate(header_row) if isinstance(cell, str)
            }
            required = ["Employee Name", "Open Date Time"]
            missing = [col for col in required if _norm(col) not in header_map]
            if missing:
                missing_required = missing
                continue

            name_idx = header_map[_norm("Employee Name")]
            open_idx = header_map[_norm("Open Date Time")]
            work_idx = header_map.get(_norm("Work Order Number"))

            if target_date is None:
                target_cell = sheet.cell(row=2, column=1).value
                target_date = excel_to_date(target_cell)
                prev_day = prev_business_day(target_date)

            for row in sheet.iter_rows(min_row=header_row_idx + 1, values_only=True):
                if row and any(
                    _norm(cell) == marker_norm for cell in row if isinstance(cell, str)
                ):
                    continue
                if not row or row[name_idx] in (None, ""):
                    continue
                if work_idx is not None:
                    wo = row[work_idx]
                    if not wo or not str(wo).startswith("17"):
                        continue
                tech_raw = str(row[name_idx]).strip()
                tech = canonical_name(tech_raw, valid_names or [])
                if valid_names and tech not in valid_names:
                    unknown.add(tech_raw)

                open_date = excel_to_date(row[open_idx])
                data = summary.setdefault(tech, {"total": 0, "new": 0, "old": 0})
                data["total"] += 1
                if prev_day is not None and open_date == prev_day:
                    data["new"] += 1
                else:
                    data["old"] += 1

        if target_date is None:
            if missing_required:
                raise ValueError(
                    "Missing required column(s): " + ", ".join(missing_required)
                )
            raise ValueError("Header row not found in report")

        unknown_list = sorted(unknown)
        return target_date, summary, unknown_list


def update_liste(
    liste: Path,
    month_sheet: str,
    day: dt.date,
    morning: Dict[str, Dict[str, int]],
):
    """Write aggregated values into the ``Liste.xlsx`` workbook.

    Nur die Werte aus dem Morgenreport werden übernommen; Abendberichte
    werden nicht mehr berücksichtigt. Bereits eingetragene Datumswerte
    in der Liste bleiben unverändert.
    """
    if not morning:
        raise ValueError("Morning report produced no data")
    wb = safe_load_workbook(liste)
    try:
        if month_sheet not in wb.sheetnames:
            ws = wb.create_sheet(title=month_sheet)
            ws.cell(row=1, column=1, value="Techniker")
        else:
            ws = wb[month_sheet]

        # Canonicalise technician names already present in the sheet
        names_in_sheet: list[str] = []
        for row in range(2, ws.max_row + 1):
            cell = ws.cell(row=row, column=1)
            if not cell.value:
                continue
            name = str(cell.value).strip()
            canon = canonical_name(name, names_in_sheet)
            cell.value = canon
            names_in_sheet.append(canon)

        def canonicalize_summary(summary: Dict[str, Dict[str, int]]) -> Dict[str, Dict[str, int]]:
            result: Dict[str, Dict[str, int]] = {}
            for name, stats in summary.items():
                canon = canonical_name(name, names_in_sheet)
                agg = result.setdefault(canon, {"total": 0, "new": 0, "old": 0})
                agg["total"] += stats["total"]
                agg["new"] += stats["new"]
                agg["old"] += stats["old"]
            return result

        morning = canonicalize_summary(morning)

        # Determine the start column for the given date.  ``Liste.xlsx`` stores
        # daily values in blocks of 13 columns, separated by an empty column.
        # Seven such blocks form a week.  The previous implementation only
        # considered the week index which caused all days of the same week to
        # overwrite each other.  We now also offset by the weekday inside the
        # week so each day has its own column range.
        week_index = (day.day - 1) // 7
        day_index = (day.day - 1) % 7
        start_col = 1 + week_index * 14 * 7 + day_index * 14
        remaining = set(morning)

        for row in range(2, ws.max_row + 1):
            name_cell = ws.cell(row=row, column=1)
            tech = str(name_cell.value).strip() if name_cell.value else None
            if not tech or tech not in morning:
                continue
            remaining.discard(tech)
            day_data = morning[tech]
            # Datum nur setzen, wenn die Zelle leer ist
            date_cell = ws.cell(row=row, column=start_col + 1)
            if date_cell.value is None:
                date_cell.value = day
            ws.cell(row=row, column=start_col + 2).value = PREV_DAY_MAP[day.weekday()]
            ws.cell(row=row, column=start_col + 8).value = day_data["total"]
            ws.cell(row=row, column=start_col + 9).value = day_data["old"]
            ws.cell(row=row, column=start_col + 10).value = day_data["new"]

        for tech in remaining:
            row = ws.max_row + 1
            ws.cell(row=row, column=1).value = tech
            day_data = morning[tech]
            date_cell = ws.cell(row=row, column=start_col + 1)
            if date_cell.value is None:
                date_cell.value = day
            ws.cell(row=row, column=start_col + 2).value = PREV_DAY_MAP[day.weekday()]
            ws.cell(row=row, column=start_col + 8).value = day_data["total"]
            ws.cell(row=row, column=start_col + 9).value = day_data["old"]
            ws.cell(row=row, column=start_col + 10).value = day_data["new"]

        wb.save(liste)
    finally:
        wb.close()


def _init_month_logger(log_file: Path | None) -> None:
    """Initialisiere eine einfache Logausgabe für die Monatsverarbeitung."""

    fmt = logging.Formatter("%(asctime)s %(levelname)s %(message)s")

    if not logger.handlers:
        logger.setLevel(logging.INFO)
        stream = logging.StreamHandler()
        stream.setFormatter(fmt)
        logger.addHandler(stream)
        logger.propagate = False

    if log_file is not None and not any(
        isinstance(h, logging.FileHandler) and Path(h.baseFilename) == log_file
        for h in logger.handlers
    ):
        log_file.parent.mkdir(parents=True, exist_ok=True)
        file_handler = logging.FileHandler(log_file, encoding="utf-8")
        file_handler.setFormatter(fmt)
        logger.addHandler(file_handler)


def process_month(
    month_dir: Path, liste: Path, log_file: Path | None = Path("logs/process_month.log")
) -> None:
    """Process all day report directories within ``month_dir``.

    Während der Verarbeitung werden Fortschrittsmeldungen sowohl auf der
    Konsole als auch optional in ``log_file`` ausgegeben. So ist ersichtlich,
    ob der Vorgang noch läuft oder bereits abgeschlossen ist.
    """

    _init_month_logger(log_file)
    logger.info("Starte Verarbeitung für %s", month_dir)

    for day_dir in sorted(p for p in month_dir.iterdir() if p.is_dir()):
        morning = list(day_dir.glob("*7*.xlsx"))
        if not morning:
            logger.debug("Kein Morgenreport in %s, überspringe", day_dir)
            continue
        logger.info("Verarbeite %s", day_dir.name)
        try:
            main([str(day_dir), str(liste)])
        except Exception:  # pragma: no cover - Fehler protokollieren
            logger.exception("Fehler bei der Verarbeitung von %s", day_dir)
        else:
            logger.info("Fertig %s", day_dir.name)

    logger.info("Monatsverarbeitung abgeschlossen")


def main(argv: Iterable[str] | None = None) -> None:
    parser = argparse.ArgumentParser(description="Process dispatch reports")
    parser.add_argument(
        "day_dir",
        type=Path,
        help="Directory containing daily reports (e.g. reports/2025-07/01)",
    )
    parser.add_argument("liste", type=Path, help="Path to Liste.xlsx")
    parser.add_argument(
        "--date",
        type=lambda s: dt.datetime.strptime(s, "%d.%m.%Y").date(),
        help="Datum, das in die Liste eingetragen werden soll (dd.mm.yyyy)",
    )
    args = parser.parse_args(list(argv) if argv is not None else None)

    # Der Monat und das Jahr ergeben sich aus dem übergeordneten Ordner
    # ``YYYY-MM``. Fehlt diese Information, wird das aktuelle Jahr verwendet.
    parent = args.day_dir.parent.name
    try:
        year_month = dt.datetime.strptime(parent, "%Y-%m")
    except ValueError:
        year_month = dt.datetime(dt.date.today().year, dt.date.today().month, 1)

    if args.date:
        day = args.date
    else:
        day = dt.date(year_month.year, year_month.month, int(args.day_dir.name))
    month_sheet = f"{MONTH_MAP[day.month]}_{day.strftime('%y')}"

    # Read existing technician names to aid fuzzy matching
    name_wb = safe_load_workbook(args.liste)
    if month_sheet not in name_wb.sheetnames:
        ws_names = name_wb.create_sheet(title=month_sheet)
        ws_names.cell(row=1, column=1, value="Techniker")
        name_wb.save(args.liste)
    else:
        ws_names = name_wb[month_sheet]
    valid_names = [
        str(ws_names.cell(row=r, column=1).value).strip()
        for r in range(2, ws_names.max_row + 1)
        if ws_names.cell(row=r, column=1).value
    ]
    name_wb.close()

    morning_files = list(args.day_dir.glob("*7*.xlsx"))
    if not morning_files:
        raise FileNotFoundError(
            f"Morning report (*7*.xlsx) not found in {args.day_dir}"
        )
    morning = morning_files[0]

    target_date, morning_summary, _ = load_calls(morning, valid_names)
    update_liste(args.liste, month_sheet, target_date, morning_summary)


if __name__ == "__main__":
    main()
