"""
Automate dispatch call summaries.

This script processes daily technician call reports. For each day directory
(e.g. ``reports/2025-07/01``) it expects a morning file named with ``7`` and an
evening file named with ``19``. The morning report counts each technician's
total calls and how many are "new" (``Open Date Time`` equals the previous
business day) versus "old". The evening report lists the still-open calls so the
script can derive how many were completed during the day.

The aggregated values are written into ``Liste.xlsx`` on the sheet for the
corresponding month. The workbook contains weekly column blocks consisting of
13 columns:

    name, date, weekday, pudo, pickup time, valid, info, pre-closed,
    total calls, old calls, new calls, details, mails

Blocks sind zu Wochen gruppiert, zwischen denen eine Leer-Spalte liegt. Eine
Woche besteht somit aus sieben 13-Spalten-Blöcken plus einer zusätzlichen
Leer-Spalte. Für ein Datum ``d`` ergibt sich der Wochenindex ``(d.day-1)//7``
und der Tagesindex ``(d.day-1)%7``. Die Startspalte lautet folglich
``1 + week_index*(13*7 + 1) + day_index*13``.

The script requires :mod:`openpyxl` for reading and writing Excel files.
"""

from __future__ import annotations

import argparse
import datetime as dt
import logging
import re
from pathlib import Path
from typing import Dict, Iterable, Tuple
import os
import tempfile
import warnings
from contextlib import closing
from .name_aliases import canonical_name, refresh_alias_map


logger = logging.getLogger(__name__)

try:  # pragma: no cover - import guard
    from openpyxl import load_workbook
except Exception:  # pragma: no cover - missing dependency
    load_workbook = None  # type: ignore[assignment]
    _from_excel = None
else:  # pragma: no cover - optional helper
    try:
        from openpyxl.utils.datetime import from_excel as _from_excel
    except Exception:  # pragma: no cover - missing helper
        _from_excel = None

# Known noisy openpyxl warnings to suppress when loading workbooks.
OPENPYXL_WARNINGS = [
    "Workbook contains no default style, apply openpyxl's default",
    "Data Validation extension is not supported and will be removed",
]

# Only worksheets whose title matches one of these patterns are considered
# relevant for call extraction. Weitere im Feld verwendete Bezeichnungen wie
# "West Central" oder "Detailed" werden nun ebenfalls berücksichtigt.
RELEVANT_SHEET_PATTERNS = [
    re.compile(pattern, re.IGNORECASE)
    for pattern in ["report", "west central", "detailed"]
]

# Standardmuster für den Morgenreport
DEFAULT_MORNING_PATTERN = "*7*.xlsx"


# Sicherstellen, dass der Alias-Cache aktuell ist.
refresh_alias_map()


def safe_load_workbook(filename: Path | str, *args, **kwargs):
    """Load a workbook while suppressing known openpyxl warnings.

    Some Excel files generated by third-party systems trigger noisy warnings
    about missing default styles or unsupported data validation extensions.
    These warnings are irrelevant for our processing and would clutter the
    output, especially on Windows where they are printed for every run.

    Parameters mirror :func:`openpyxl.load_workbook`.
    """

    path = Path(filename)
    if not path.exists():
        raise FileNotFoundError(f"Workbook not found: {path}")

    if load_workbook is None:
        raise RuntimeError("openpyxl is required to load workbooks")

    with warnings.catch_warnings():
        for msg in OPENPYXL_WARNINGS:
            warnings.filterwarnings("ignore", message=msg, category=UserWarning)
        return load_workbook(path, *args, **kwargs)

# Markierungen, die auf Kopfzeilen hinweisen können (für wiederholte Zeilen)
HEADER_MARKERS = ["Employee ID", "Mitarbeiter-ID"]
PREV_DAY_MAP = {
    0: "Montag",
    1: "Dienstag",
    2: "Mittwoch",
    3: "Donnerstag",
    4: "Freitag",
    5: "Samstag",
    6: "Sonntag",
}

# Mapping of month numbers to German month names used in ``Liste.xlsx``
MONTH_MAP = {
    1: "Januar",
    2: "Februar",
    3: "März",
    4: "April",
    5: "Mai",
    6: "Juni",
    7: "Juli",
    8: "August",
    9: "September",
    10: "Oktober",
    11: "November",
    12: "Dezember",
}


def excel_to_date(value):
    """Wandle Excel-Seriennummern oder Datumswerte in :class:`datetime.date` um."""
    if value is None:
        raise ValueError("Leere Zelle kann nicht in ein Datum umgewandelt werden")

    if isinstance(value, dt.datetime):
        return value.date()

    try:
        number = float(value)
    except (TypeError, ValueError) as exc:  # pragma: no cover - defensive
        raise ValueError(f"Ungültiger Datumswert: {value!r}") from exc

    if _from_excel is not None:  # pragma: no cover - depends on optional helper
        dt_obj = _from_excel(number)
        if isinstance(dt_obj, dt.datetime):
            return dt_obj.date()
        if isinstance(dt_obj, dt.date):
            return dt_obj
        raise ValueError(f"Ungültiger Datumswert: {value!r}")

    origin = dt.date(1899, 12, 30)
    return origin + dt.timedelta(days=number)


def prev_business_day(day: dt.date) -> dt.date:
    """Return the previous business day (skip weekends)."""
    day -= dt.timedelta(days=1)
    while day.weekday() >= 5:  # 5=Sat,6=Sun
        day -= dt.timedelta(days=1)
    return day


def load_calls(
    path: Path,
    valid_names: Iterable[str] | None = None,
) -> Tuple[dt.date, Dict[str, Dict[str, int]], list[str]]:
    """Load a call report and summarise per technician.

    Parameters
    ----------
    path:
        Excel file to read.
    valid_names:
        Iterable of canonical names from ``Liste.xlsx`` used to match
        technician names via fuzzy comparison.
    """
    with closing(safe_load_workbook(path, data_only=True, read_only=True)) as wb:
        def _norm(value: str) -> str:
            return value.strip().lower()

        header_markers_norm = [_norm(m) for m in HEADER_MARKERS]
        required_headers = [_norm("Employee Name"), _norm("Open Date Time")]
        summary: Dict[str, Dict[str, int]] = {}
        unknown: set[str] = set()
        target_date: dt.date | None = None
        prev_day: dt.date | None = None
        missing_required: list[str] | None = None
        seen_work_orders: set[str] = set()
        sheet_names = list(wb.sheetnames)
        found_relevant = False

        for sheet in wb.worksheets:
            # Überspringe Arbeitsblätter, die keine der definierten
            # Bezeichnungen enthalten. Ist die Liste leer, werden alle
            # Blätter verarbeitet.
            if RELEVANT_SHEET_PATTERNS and not any(
                p.search(sheet.title) for p in RELEVANT_SHEET_PATTERNS
            ):
                continue

            found_relevant = True

            header_row = None
            header_row_idx = None
            for idx, row in enumerate(
                sheet.iter_rows(min_row=1, max_row=20, values_only=True), 1
            ):
                if not row:
                    continue
                normalized = [_norm(cell) for cell in row if isinstance(cell, str)]
                if all(req in normalized for req in required_headers):
                    header_row = list(row)
                    header_row_idx = idx
                    break
            if header_row is None:
                continue

            header_map = {
                _norm(cell): idx for idx, cell in enumerate(header_row) if isinstance(cell, str)
            }
            required = ["Employee Name", "Open Date Time"]
            missing = [col for col in required if _norm(col) not in header_map]
            if missing:
                missing_required = missing
                continue

            name_idx = header_map[_norm("Employee Name")]
            open_idx = header_map[_norm("Open Date Time")]
            work_idx = header_map.get(_norm("Work Order Number"))

            if target_date is None:
                target_cell = sheet.cell(row=2, column=1).value
                target_date = excel_to_date(target_cell)
                prev_day = prev_business_day(target_date)

            for row in sheet.iter_rows(min_row=header_row_idx + 1, values_only=True):
                if not row:
                    continue
                normalized = [_norm(cell) for cell in row if isinstance(cell, str)]
                if (
                    any(val in header_markers_norm for val in normalized)
                    or all(req in normalized for req in required_headers)
                ):
                    continue
                if row[name_idx] in (None, ""):
                    continue
                if work_idx is not None:
                    wo_val = row[work_idx]
                    if not wo_val:
                        continue
                    if isinstance(wo_val, (int, float)):
                        wo_str = str(int(wo_val))
                    else:
                        wo_str = str(wo_val).strip()
                    if not wo_str.startswith("17") or wo_str in seen_work_orders:
                        continue
                    seen_work_orders.add(wo_str)
                raw_name = str(row[name_idx]).strip()
                tech = canonical_name(raw_name, valid_names or [])
                if valid_names and tech not in valid_names:
                    unknown.add(raw_name)
                    continue

                open_date = excel_to_date(row[open_idx])
                data = summary.setdefault(tech, {"total": 0, "new": 0, "old": 0})
                data["total"] += 1
                if prev_day is not None and open_date == prev_day:
                    data["new"] += 1
                else:
                    data["old"] += 1

        if RELEVANT_SHEET_PATTERNS and not found_relevant:
            patterns = ", ".join(p.pattern for p in RELEVANT_SHEET_PATTERNS)
            raise ValueError(
                "Keine passenden Arbeitsblätter gefunden. Gesuchte Muster: "
                f"{patterns}. Vorhandene Blätter: {', '.join(sheet_names)}"
            )

        if target_date is None:
            if missing_required:
                raise ValueError(
                    "Missing required column(s): " + ", ".join(missing_required)
                )
            raise ValueError("Header row not found in report")

        unknown_list = sorted(unknown)
        return target_date, summary, unknown_list


def extract_calls_by_id(report_path: Path, ids: Iterable[str]) -> dict[str, list[str]]:
    """Lese alle Call-Nummern je Techniker-ID aus einem Report.

    Parameters
    ----------
    report_path:
        Pfad zur Excel-Datei des Reports.
    ids:
        Iterable mit Techniker-IDs, für die die Call-Nummern extrahiert werden
        sollen.
    """

    id_set = {str(i).strip() for i in ids}
    calls_by_id: dict[str, list[str]] = {i: [] for i in id_set}

    with closing(safe_load_workbook(report_path, read_only=True, data_only=True)) as wb:
        ws = wb.worksheets[0]
        for row in ws.iter_rows(min_row=1, max_col=3, values_only=True):
            id_val = row[0] if len(row) > 0 else None
            call_val = row[2] if len(row) > 2 else None

            if id_val is None or call_val is None:
                continue

            id_str = str(id_val).strip()
            if id_str not in id_set:
                continue

            call_str = str(call_val).strip()
            if not call_str.startswith("17"):
                continue

            calls_by_id.setdefault(id_str, []).append(call_str)

    return {k: v for k, v in calls_by_id.items() if v}


def update_liste(
    liste: Path,
    month_sheet: str,
    day: dt.date,
    morning: Dict[str, Dict[str, int]],
):
    """Write aggregated values into the ``Liste.xlsx`` workbook.

    Nur die Werte aus dem Morgenreport werden übernommen; Abendberichte
    werden nicht mehr berücksichtigt. Bereits eingetragene Datumswerte
    in der Liste bleiben unverändert.
    """
    if not morning:
        raise ValueError("Morning report produced no data")
    wb = safe_load_workbook(liste)
    try:
        if month_sheet not in wb.sheetnames:
            ws = wb.create_sheet(title=month_sheet)
            ws.cell(row=1, column=1, value="Techniker")
        else:
            ws = wb[month_sheet]

        # Canonicalise technician names already present in the sheet
        names_in_sheet: list[str] = []
        for row in range(2, ws.max_row + 1):
            cell = ws.cell(row=row, column=1)
            if not cell.value:
                continue
            canon = canonical_name(str(cell.value).strip(), names_in_sheet)
            cell.value = canon
            names_in_sheet.append(canon)

        def canonicalize_summary(summary: Dict[str, Dict[str, int]]) -> Dict[str, Dict[str, int]]:
            result: Dict[str, Dict[str, int]] = {}
            for name, stats in summary.items():
                canon = canonical_name(name, names_in_sheet)
                agg = result.setdefault(canon, {"total": 0, "new": 0, "old": 0})
                agg["total"] += stats["total"]
                agg["new"] += stats["new"]
                agg["old"] += stats["old"]
            return result

        morning = canonicalize_summary(morning)

        # Starte Spalte gemäß dem in ``Liste.xlsx`` verwendeten Layout
        # bestimmen. Tageswerte stehen in 13-Spalten-Blöcken, sieben Blöcke
        # bilden eine Woche, zwischen Wochen liegt eine Leer-Spalte. Der
        # Wochenindex und der Tagesindex innerhalb der Woche verschieben den
        # Start entsprechend.
        week_index = (day.day - 1) // 7
        day_index = (day.day - 1) % 7
        start_col = 1 + week_index * (13 * 7 + 1) + day_index * 13
        remaining = set(morning)

        for row in range(2, ws.max_row + 1):
            name_cell = ws.cell(row=row, column=1)
            tech = (
                canonical_name(str(name_cell.value).strip(), names_in_sheet)
                if name_cell.value
                else None
            )
            if not tech or tech not in morning or tech not in remaining:
                continue

            date_cell = ws.cell(row=row, column=start_col + 1)
            if date_cell.value is None:
                logger.warning(
                    "Keine Datumsangabe in Zeile %s für Techniker %s, setze Datum auf %s.",
                    row,
                    tech,
                    day,
                )
                date_cell.value = day
                cell_date = day
            else:
                try:
                    cell_date = excel_to_date(date_cell.value)
                except ValueError:
                    logger.warning(
                        "Ungültige Datumsangabe in Zeile %s für Techniker %s: %r, setze Datum auf %s.",
                        row,
                        tech,
                        date_cell.value,
                        day,
                    )
                    date_cell.value = day
                    cell_date = day
            if cell_date != day:
                continue

            day_data = morning[tech]
            ws.cell(row=row, column=start_col + 2).value = PREV_DAY_MAP[day.weekday()]
            ws.cell(row=row, column=start_col + 8).value = day_data["total"]
            ws.cell(row=row, column=start_col + 9).value = day_data["old"]
            ws.cell(row=row, column=start_col + 10).value = day_data["new"]
            remaining.discard(tech)

        if remaining:
            for tech in sorted(remaining):
                canon = canonical_name(tech, names_in_sheet)
                row = ws.max_row + 1
                ws.cell(row=row, column=1, value=canon)
                ws.cell(row=row, column=start_col + 1, value=day)
                ws.cell(row=row, column=start_col + 2, value=PREV_DAY_MAP[day.weekday()])
                day_data = morning[tech]
                ws.cell(row=row, column=start_col + 8, value=day_data["total"])
                ws.cell(row=row, column=start_col + 9, value=day_data["old"])
                ws.cell(row=row, column=start_col + 10, value=day_data["new"])
                names_in_sheet.append(canon)

        wb.save(liste)
    finally:
        wb.close()


def _init_month_logger(log_file: Path | None) -> None:
    """Initialisiere eine einfache Logausgabe für die Monatsverarbeitung."""

    fmt = logging.Formatter("%(asctime)s %(levelname)s %(message)s")

    if not logger.handlers:
        logger.setLevel(logging.INFO)
        stream = logging.StreamHandler()
        stream.setFormatter(fmt)
        logger.addHandler(stream)
        logger.propagate = False

    if log_file is not None and not any(
        isinstance(h, logging.FileHandler) and Path(h.baseFilename) == log_file
        for h in logger.handlers
    ):
        log_file.parent.mkdir(parents=True, exist_ok=True)
        file_handler = logging.FileHandler(log_file, encoding="utf-8")
        file_handler.setFormatter(fmt)
        logger.addHandler(file_handler)


def find_morning_file(day_dir: Path, pattern: str) -> tuple[Path | None, list[Path], bool]:
    """Finde die Datei für den Morgenreport.

    Gibt einen Tupel aus gewählter Datei, allen gefundenen `.xlsx`-Dateien
    sowie einem Flag zurück, das angibt, ob das Muster `pattern` getroffen
    wurde.
    """

    matched = sorted(day_dir.glob(pattern))
    if matched:
        return matched[0], matched, True

    candidates = sorted(day_dir.glob("*.xlsx"))
    if candidates:
        return candidates[0], candidates, False

    return None, [], False


def process_month(
    month_dir: Path,
    liste: Path,
    log_file: Path | None = None,
    morning_pattern: str = DEFAULT_MORNING_PATTERN,
) -> None:
    """Process all day report directories within ``month_dir``.

    Während der Verarbeitung werden Fortschrittsmeldungen sowohl auf der
    Konsole als auch optional in ``log_file`` ausgegeben. So ist ersichtlich,
    ob der Vorgang noch läuft oder bereits abgeschlossen ist.
    """

    if log_file is None:
        default_dir = Path(
            os.environ.get(
                "DISPATCH_LOG_DIR", str(Path(tempfile.gettempdir()) / "dispatch_logs")
            )
        )
        log_file = default_dir / "process_month.log"
    _init_month_logger(log_file)
    logger.info("Starte Verarbeitung für %s", month_dir)

    for day_dir in sorted(p for p in month_dir.iterdir() if p.is_dir()):
        if not any(day_dir.glob("*.xlsx")):
            logger.debug("Keine Excel-Dateien in %s, überspringe", day_dir)
            continue
        logger.info("Verarbeite %s", day_dir.name)
        try:
            main(
                [
                    str(day_dir),
                    str(liste),
                    "--morning-pattern",
                    morning_pattern,
                ]
            )
        except Exception:  # pragma: no cover - Fehler protokollieren
            logger.exception("Fehler bei der Verarbeitung von %s", day_dir)
        else:
            logger.info("Fertig %s", day_dir.name)

    logger.info("Monatsverarbeitung abgeschlossen")


def main(argv: Iterable[str] | None = None) -> None:
    parser = argparse.ArgumentParser(description="Process dispatch reports")
    parser.add_argument(
        "day_dir",
        type=Path,
        help="Directory containing daily reports (e.g. reports/2025-07/01)",
    )
    parser.add_argument("liste", type=Path, help="Path to Liste.xlsx")
    parser.add_argument(
        "--date",
        type=lambda s: dt.datetime.strptime(s, "%d.%m.%Y").date(),
        help="Datum, das in die Liste eingetragen werden soll (dd.mm.yyyy)",
    )
    parser.add_argument(
        "--morning-pattern",
        default=DEFAULT_MORNING_PATTERN,
        help="Globbing-Muster für den Morgenreport",
    )
    args = parser.parse_args(list(argv) if argv is not None else None)

    # Der Monat und das Jahr ergeben sich aus dem übergeordneten Ordner
    # ``YYYY-MM``. Fehlt diese Information, wird das aktuelle Jahr verwendet.
    parent = args.day_dir.parent.name
    try:
        year_month = dt.datetime.strptime(parent, "%Y-%m")
    except ValueError:
        year_month = dt.datetime(dt.date.today().year, dt.date.today().month, 1)

    if args.date:
        day = args.date
    else:
        day = dt.date(year_month.year, year_month.month, int(args.day_dir.name))
    month_sheet = f"{MONTH_MAP[day.month]}_{day.strftime('%y')}"

    # Read existing technician names to aid fuzzy matching
    name_wb = safe_load_workbook(args.liste)
    if month_sheet not in name_wb.sheetnames:
        print(f"Arbeitsblatt '{month_sheet}' existiert nicht.")
        print("Verfügbare Blätter:", ", ".join(name_wb.sheetnames))
        choice = input(
            "Neues Blatt anlegen? (j/n) oder Namen eines vorhandenen Blatts eingeben: "
        ).strip()
        if choice.lower() in {"j", "ja", "y"}:
            ws_names = name_wb.create_sheet(title=month_sheet)
            ws_names.cell(row=1, column=1, value="Techniker")
            name_wb.save(args.liste)
        elif choice in name_wb.sheetnames:
            ws_names = name_wb[choice]
            month_sheet = choice
        else:
            name_wb.close()
            raise ValueError("Kein gültiges Blatt gewählt; Abbruch.")
    else:
        ws_names = name_wb[month_sheet]
    valid_names = [
        str(ws_names.cell(row=r, column=1).value).strip()
        for r in range(2, ws_names.max_row + 1)
        if ws_names.cell(row=r, column=1).value
    ]
    name_wb.close()

    morning, candidates, matched = find_morning_file(
        args.day_dir, args.morning_pattern
    )
    if morning is None:
        raise FileNotFoundError(
            f"Keine Excel-Dateien in {args.day_dir} gefunden"
        )
    if not matched:
        names = ", ".join(c.name for c in candidates)
        print(
            f"Kein Morgenreport nach Muster '{args.morning_pattern}' gefunden."
        )
        print(f"Verfügbare Dateien: {names}")
        print(f"Verwende {morning.name} als Fallback.")

    target_date, morning_summary, _ = load_calls(morning, valid_names)
    update_liste(args.liste, month_sheet, target_date, morning_summary)


if __name__ == "__main__":
    main()
